---
title: "Markov Matrix"
author: "Angela Lee"
date: "5/17/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
getwd()
```

### Transition Matrix



```{r example Page Rank}
A <- matrix(c(0,0,1, 0,0, 1, 1/3, 1/3, 1/3), nrow = 3)
eigen(A)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
B <- matrix(c(0,1,0, 0,0, 1, rep(0,7), 1/2, 1/2), nrow = 3)
eigen(A)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
library(matlib)
A <- matrix(c(1,1,1,1,2,5,7,8), nrow = 4)
B <- matrix(c(1,2,3,3), nrow = 4)
xhat <- inv(t(A) %*% A) %*% t(A) %*% B
xhat
```

Example: MultiChannel Image Processing - reduced from 3 to 1 dimension
Y1 = - 0.54x1 - 0.63x2 - 0.56x3
```{r}
Cov_S <- matrix(c(2382.78, 2611.84, 2136.2, 2611.84, 3106.47, 2553.90, 2136.2, 2553.9,
                  2650.71), nrow = 3)
E <- eigen(Cov_S) 

E$values[1] / sum(E$values)
E$values[2] / sum(E$values)
E$values[3] / sum(E$values)
```
Principal Components Analysis - prcomp
scaling is such that the standard deviation = 1.
```{r}
library(stats)
d = longley[, -c(6,7)]
dPCA = prcomp(d, scale = TRUE)
plot(dPCA, type = "l")
#plot(dPCA)

#predict is used to find the new corrdinates using the eigen vectors of the original dataset
predict(dPCA, newdata = d)
```

Biplot
```{r}
biplot(dPCA)
```

```{r}
dPCA3 <- princomp(d, cor = TRUE, scores = TRUE)
summary(dPCA3)
```

Preprocessing
```{r}
library(caret)
dPCA2 <- preProcess(d, method = c("center", "scale", "pca"), thresh = 0.9, pcaComp = 3)
predict(dPCA2, newdata = d)
```

```{r}
library(MASS)
A <- matrix(c(6,-2,1,-2,6,-1,-1,-1,5 ), nrow = 3)
D <- eigen(A)
D$values
D$vectors
D$vectors %*% diag(D$values) %*% ginv(D$vectors)

```

Find a unit vector x at which the length |Ax| is maximized and compute this maximum length.

```{r}

# Define matrices Aa and A
Aa <- matrix(c(4, 8, 11, 7, 14, -2), nrow = 2)
A <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2)

# Calculate the generalized inverse of Aa
ginv_Aa <- ginv(Aa)

# Check the dimensions of ginv_Aa
dim(ginv_Aa)

# Multiply the generalized inverse by matrix A
result <- ginv_Aa %*% A

# Display the result
print(result)

```
Find SVD for the matrix

```{r}
A <- matrix(c(-18, 2, -14, -2, 13, 19, 11, 21, -4, -4, -12, 4, 4, 12, 8, 8), nrow = 4)
svd(A)
```

# statistics I examples
```{r}
pnorm(-2.65)

9.6 - sqrt(40)

(28.6 - 31) / (9.6 / sqrt(40))
2* pnorm(-1.58)

2* pnorm(11.85, mean = 12, sd = 0.5/sqrt(100))
```
```{r}
library(BSDA)
attach(Anxiety)

m <- lm(math ~ anxiety)
plot(anxiety, math)
abline(m)
summary(m)$r.squared
residual <- resid(m)
plot(anxiety, residual, ylab = "Residual", abline(0,0, col = "red"))

```

Simulation - # the probability mass function (PMF) is 

```{r}
x <- seq(0, 10)
p <- dbinom(x, size = 10, prob = 0.3)
plot(x, p, type = "h", lwd = 5, main = "probability of getting x heads in 10 tosses", xlab = "# of heads", ylab = "P(X= x)")

# the probability mass function (PMF) is 
p
```

Binomial probability 

```{r}
sample <- rbinom(n = 10000, size = 10, p = 0.3)
hist(sample, main = "Histogram of samples from Binomial", col = "royal blue", right = FALSE)
m = mean(sample)
s = sd(sample)
```

Bayesian 
```{r}
p = seq(0.05, 1, 0.1)
prior = c(0.005, 0.01, 0.9, 0.02, 0.01, 0.01, 0.01, 0.01, 0.01, 0.005 )
L = p^4 *(1-p)^6
posterior = L * prior 
normalized_posterior = posterior / sum(posterior)
plot(p, posterior, ylab = "Posterior Probability", lwd = 10, type = "h")
```

Naive Bayes Classfier in R

```{r}
library(e1071)
tr = read.csv('soccerData2.csv')
summary(tr)
model = naiveBayes(Play ~., data = tr); model

```

Predict Using the Naive Bayes Model 
Declare a data frame

```{r}
test = data.frame(Temperature = "Mild", Wind = "Weak", Precipitation = "Rain", Humidity = "High")
sapply(test, levels)
trLevels = sapply(tr, levels)
#all levels for the test set must be equal to the training set
for (i in 1:4){
  test[[i]]= factor(test[[i]], levels = trLevels[[i]])
}

output = predict(model, test, "class"); output
output = predict(model, test, "raw"); output
```

